---
type: redis概述
title: redis概述
date: 2019-07-06
category: redis
tags:
- redis
description: redis一些知识点
---

#### redis技巧

##### redis做消息中间件

​	一般使用list结构作为队列，**rpush**生产消息，**lpop**消费消息。当lpop没有消息的时候，要适当sleep一会再重试。不用sleep就用**blpop**，在没有消息的时候，它会阻塞住直到消息到来。

​	利用发布订阅模式完成，若要一条消息多次消费可以采用发布订阅者模式搭配rpush与lpop命令来完成。

##### 防止缓存雪崩

​	要防止缓存雪崩就要先处理好同一时刻大量key失效的问题，这种情况一般出现在定期刷新页面数据的网站，所以要通过在时间上设置随机值来达到分散失效时间的目的。

##### 分布式锁

先拿**setnx**来争抢锁，抢到之后，再用**expire**给锁加一个过期时间防止锁忘记了释放。

如果在setnx之后执行expire之前进程意外crash或者要重启维护了，这样抢到的锁没有设置过期时间就不会释放了，set指令有非常复杂的参数，这个应该是可以同时把**setnx**和**expire**合成一条指令来用的！

##### keys命令扫描出指定模式的key列表

问题：redis是单线程，扫描过程中会让redis其他业务停顿直到扫描完成，可以采用scan命令无阻塞的去查找，但是会有重复的概率需要客户端做去重。

#### redis哨兵机制

redis哨兵机制的理解概述

首先，每个哨兵节点每秒都会向主从服务器，其它的哨兵节点发送心跳包（检测是否在线），如果在配置时间内主节点都返回无效的回复，则该哨兵会认为主节点客观下线。为了确定主服务器是否真的下线，该哨兵会向其它哨兵节点询问，如果收到确认主服务器下线回复超过了规定值，则该哨兵节点会认为主服务器客观下线。 所有判断主服务器客观下线的哨兵都有机会成为负责下线主服务器的故障处理的主哨兵节点。它们在确定主服务器下线后，后发起选举，它会向其它哨兵节点发消息告诉它们自己要当主哨兵，让其它哨兵投票，在一次故障处理过程中每个哨兵只能投票一次，如果发起投票的哨兵的选票达到了半数以上，那么它就会成为主哨兵节点。所以说先到先得，如果某个哨兵已经投票给其它的哨兵，那么再有请求发来也不能再进行投票。

哨兵个数最好是奇数且最少三个，如果是两个哨兵那么主节点所在的这台机器直接挂了，那么这个哨兵也挂了，此时只有一个哨兵无法进行故障转移了。

#### redis哨兵的主要功能

- 集群监控：负责监控 Redis master 和 slave 进程是否正常工作（发送心跳包根据回复判断）。
- 消息通知：如果某个 **Redis** 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

哨兵执行故障转移，将一个从节点升级为主节点，将剩余的从节点指向到新的主节并通知客户端主节点已更换，原来的主节点上线后只能作为从节点。

##### 手动实现故障转移

1.在从节点slave-1执行 slaveof no one ，将从节点变为主节点；

2.其它的节点，执行 slaveof slave-1的ip port，变为slave-1的从节点，并从新节点复制数据；

#### redis为什么快

官方给出每秒能达到十二万次的请求，但是在个人的测试中达到三万次都已经很厉害了，可能是设备的原因把。

1.基于内存，底层数据结构是hashmap这就使得查询速度快。

2.单线程：避免了上下文的切换，且不用考虑各种锁的问题。

3.多路复用的I/O模型，非阻塞IO。

4.有自己的协议RPC协议，不像http那样臃肿的协议（http也做了优化就是压缩）。

单线程对于多核CPU有些浪费，我们可以在一个服务器上设立多个实例去利用多核的优势。

#### redis的过期策略

定期删除+惰性删除两种

内存淘汰机制：在内存很满需要进行淘汰数据时才会进行的淘汰机制，LRU最近最少未使用的数据淘汰。

#### redis的持久化

rdb和aof之后补充................

#### 布隆过滤器

是对于缓存穿透的一种预防手段，也可以采用手动编码的方式去做，这样就是至少要查一次如果不存在就返回空并且在redis中保存相应的key与value。布隆过滤器也是一样的思想：

当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。

**缺点：**

1. 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。
2. 删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用Counting Bloom Filter

Demo

```java
/**
 * 测试布隆过滤器(可用于redis缓存穿透)
 */
public class TestBloomFilter {

    private static int total = 1000000;
    private static BloomFilter<Integer> bf = BloomFilter.create(Funnels.integerFunnel(), total);
//    private static BloomFilter<Integer> bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);

    public static void main(String[] args) {
        // 初始化1000000条数据到过滤器中
        for (int i = 0; i < total; i++) {
            bf.put(i);
        }

        // 匹配已在过滤器中的值，是否有匹配不上的
        for (int i = 0; i < total; i++) {
            if (!bf.mightContain(i)) {
                System.out.println("有坏人逃脱了~~~");
            }
        }

        // 匹配不在过滤器中的10000个值，有多少匹配出来
        int count = 0;
        for (int i = total; i < total + 10000; i++) {
            if (bf.mightContain(i)) {
                count++;
            }
        }
        System.out.println("误伤的数量：" + count);
    }

}

```
结果：误伤数量：320

![Wallbase - dgnfly (wallbase.cc/wallpaper/1384450)](http://ww1.sinaimg.cn/large/81b78497jw1emfgts2pt4j21hc0u0k1c.jpg)


