---
title:  类加载
date: 2019-02-19 21:50:06
categories:
- JAVA
---

#### 类的加载过程：

#### 一、加载：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

#### 二、连接：

​	1.验证：

​		1）文件格式验证：验证字节流是否符合Class文件规范。版本号是否能被虚拟机接受。常量池是否有不被支持的类型。

​		2）元数据验证：语义分析，是否有父类（除了object都有），final修饰的类不能被继承等。

​		3）字节码验证：确保程序语义是否合法。

​		4）符号应用验证：确保解析动作能正确执行。

​	2.准备：

​		**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

​		1）这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例			化时随着对象一块分配在 Java 堆中。

​		2）这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如			我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而			不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字`public 			  	static final int value=111` ，那么准备阶段 value 的值就被复制为 111。

​	3.解析：

​		解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

​		符号引用就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

​		综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

#### 三、初始化：

对于初始化阶段，虚拟机严格规范了有且只有5中情况下，必须对类进行初始化：

1. 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。

