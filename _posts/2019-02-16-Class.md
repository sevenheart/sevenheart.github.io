---
title: Class文件及一些细节
date: 2019-02-16
categories: 
- JAVA
tags: 
- JVM
---

#### Class文件及JVM一些总结：

​	**方法区存放的时类加载进来的Class文件，Class文件中包含必要的信息以及常量池（静态常量池），除了Class文件还包含运行时常量池**

**静态常量池：**

​	存储的是当class文件被java虚拟机加载进来后存放在方法区的一些字面量和符号引用，字面量包括字符串，基本类型的常量，符号引用其实引用的就是常量池里面的字符串，但符号引用不是直接存储字符串，而是存储字符串在常量池里的索引。

**动态常量池：**

​	是当class文件被加载完成后，java虚拟机会将静态常量池里的内容转移到动态常量池里，在静态常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。

**总结：**

​	动态常量池里的内容除了是静态常量池里的内容外，还将静态常量池里的符号引用转变为直接引用，而且动态常量池里的内容是能动态添加的。例如调用String的intern方法就能将string的值添加到String常量池中，这里String常量池是包含在动态常量池里的，但在jdk1.8后，将String常量池放到了堆中。

![](..\..\..\sources\img\JVM\常量池包含内容.png)

### JVM

![](..\..\..\sources\img\JVM\jvm运行时内存结构.png)

![](..\..\..\sources\img\JVM\JVM运行时区域详细划分.png)

#### Program Counter Register (程序计数寄存器)

1.如果当前执行的是java方法则记录的是正在执行的字节码的指令地址。如果是本地方法则为undefined。

2.作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

3.特点：线程私有。每条线程都有一个独立的程序计数器。是唯一一个不会出现OOM的内存区域。
生命周期随着线程的创建而创建，随着线程的结束而死亡。

#### 虚拟机栈：

![](..\..\..\sources\img\JVM\虚拟机栈.png)

​	每个线程独有的，当线程执行java方法时会为要执行的方法创建一个栈帧。并不是说这个运行过程中真的出现了栈这种数据结构，他只是通过记录每个方法的返回地址去实现这么一种栈的思想。

​	**栈帧中包含：**

1.局部变量表：存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。

2.操作数栈：方法运行过程中要把数据都放到栈中去按顺序操作。类似这样的感觉。

3.动态链接：常量区对方法的引用。

4.当前方法的返回地址，方法出口等信息：记住返回地址就能做到栈这样的操作了（能回溯）。

**特点：**

1.若Java虚拟机栈的内存大小不允许动态扩展,那么当线程请求的栈深度大于虚拟机允许的最大深度时(但内存空间可能还有很多),抛出**StackOverFlowError**。

2.若Java虚拟机栈的内存大小允许动态扩展,且当线程请求栈时内存用完了,无法再动态扩展了,此时抛出**OutOfMemoryError**异常



#### 本地方法栈

虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务,本地方法区则为虚拟机使用到的Native方法服务。本地方法栈调用本地方法脱离了jvm的约束，比如堆外内存的创建（NIO中引入的Buffer中的DirectBuffer基于堆外内存）

#### 堆

堆的内存空间既可以固定大小，也可运行时动态地调整，通过如下参数设定初始值和最大值，比如

```
`-Xms256M. -Xmx1024M`
```

堆分成两大块:新生代和老年代
对象产生之初在新生代，步入暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象

新生代= 1个Eden区+ 2个Survivor区

```
`-XX:MaxTenuringThreshold`
```

参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升至老年代。如果该参数配置为1,那么从新生代的Eden区直接移至老年代。默认值是15，可以在Survivor 区交换14次之后，晋升至老年代。

若Survivor区无法放下，或者超大对象的阈值超过上限，则尝试在老年代中进行分配;
如果老年代也无法放下，则会触发Full Garbage Collection(Full GC);
如果依然无法放下，则抛OOM。

**堆中保存了什么?**

除了实例数据，还保存了对象的其他信息，如Mark Word（存储对象哈希码，GC标志，GC年龄，同步锁等信息），Klass Pointy(指向存储类型元数据的指针）及一些字节对齐补白的填充数据（若实例数据刚好满足8字节对齐，则可不存在补白）  

#### 方法区（非堆）：

​	方法区是堆的一个逻辑部分,因此和堆一样,都是线程共享的。整个虚拟机中只有一个方法区.

- 线程共享
  方法区是堆的一个逻辑部分,因此和堆一样,都是线程共享的.整个虚拟机中只有一个方法区.
- 永久代
  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为永久代.
- 内存回收效率低
  Java虚拟机规范对方法区的要求比较宽松,可以不实现垃圾收集.
  方法区中的信息一般需要长期存在,回收一遍内存之后可能只有少量信息无效.
  对方法区的内存回收的主要目标是:**对常量池的回收和对类型的卸载**

和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。

当方法区内存空间无法满足内存分配需求时,将抛出OutOfMemoryError异常.

#### 直接内存

DirectByteBuffer对象就是作为这块内存的引用来操作堆的。

#### 元空间

JDK8使用元空间替换永久代.区别于永久代，元空间在本地内存（直接内存）中分配（永久代之前在jvm内存中分配）

![](..\..\..\sources\img\JVM\内存结构对比.png)